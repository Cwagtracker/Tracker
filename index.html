// Updated certificate system that loads Title Placement data

let titlePlacementData = {};

// Load Title Placement data at startup
async function loadTitlePlacementData() {
    try {
        const fileContent = await window.fs.readFile('Title Placement.xlsx');
        const workbook = XLSX.read(fileContent, {
            cellStyles: true,
            cellFormulas: true,
            cellDates: true
        });
        
        const sheetName = workbook.SheetNames[0];
        const sheet = workbook.Sheets[sheetName];
        const jsonData = XLSX.utils.sheet_to_json(sheet, {header: 1});
        
        // Create mapping from class name to certificate names
        jsonData.slice(1).forEach(row => {
            if (row && row[1] && row[2] && row[3]) {
                const className = row[1].toString().trim();
                const certificateName = row[2].toString().trim();
                const aceCertificateName = row[3].toString().trim();
                
                titlePlacementData[className] = {
                    certificateName: certificateName,
                    aceCertificateName: aceCertificateName
                };
            }
        });
        
        console.log('âœ… Title Placement data loaded:', Object.keys(titlePlacementData).length, 'classes');
        return true;
    } catch (error) {
        console.warn('âš ï¸ Could not load Title Placement data:', error.message);
        return false;
    }
}

// Helper function to get certificate name for titles
function getCertificateName(level) {
    if (titlePlacementData[level]) {
        return titlePlacementData[level].certificateName;
    }
    // Fallback to original level name if not found
    return level;
}

// Helper function to get ACE certificate name
function getAceCertificateName(level, aceCount) {
    if (titlePlacementData[level]) {
        let aceName = titlePlacementData[level].aceCertificateName;
        
        // Add the multiplier for multiple ACEs (x2, x3, x4, etc.)
        if (aceCount > 1) {
            aceName = `${aceName} x${aceCount}`;
        }
        
        return aceName;
    }
    
    // Fallback to original system if not found
    const abbreviation = titleAbbreviations[level] || level;
    return aceCount === 1 ? `${abbreviation}A` : `${abbreviation}Ax${aceCount}`;
}

// Updated generateTitleCertificate function
async function generateTitleCertificate(level, regNumber, dogName, abbreviation) {
    try {
        const btn = event.target;
        const originalText = btn.textContent;
        btn.textContent = 'Generating...';
        btn.disabled = true;

        // Get template info based on the LEVEL
        const templateInfo = certificateTemplateMapping[level];
        if (!templateInfo) {
            throw new Error(`No certificate template mapped for level: ${level}`);
        }

        // Get dog's records for this level
        const levelRecords = trialingData.filter(r => 
            r.registrationNumber === regNumber && r.level === level
        );

        if (levelRecords.length === 0) {
            throw new Error('No records found for this level');
        }

        // Calculate date earned
        const titleInfo = calculateTitlePoints(levelRecords);
        const dateEarned = titleInfo.titleDate ? titleInfo.titleDate.toLocaleDateString() : new Date().toLocaleDateString();

        // Get the proper certificate name from Title Placement data
        const certificateName = getCertificateName(level);

        // Load the template from GitHub repository
        const templateUrl = `https://raw.githubusercontent.com/cwagtracker/Tracker/main/templates/${templateInfo.template}`;
        
        let templateBytes;
        try {
            const response = await fetch(templateUrl);
            if (!response.ok) {
                throw new Error(`Template not found: ${templateUrl}`);
            }
            templateBytes = await response.arrayBuffer();
        } catch (fetchError) {
            console.warn('Template not available, creating basic certificate:', fetchError);
            return await createFallbackCertificate(dogName, regNumber, certificateName, abbreviation, dateEarned);
        }

        // Load the template PDF
        const pdfDoc = await PDFLib.PDFDocument.load(templateBytes);
        const pages = pdfDoc.getPages();
        const firstPage = pages[0];
        
        // Embed fonts
        const font = await pdfDoc.embedFont(PDFLib.StandardFonts.Helvetica);
        const boldFont = await pdfDoc.embedFont(PDFLib.StandardFonts.HelveticaBold);
        const timesBold = await pdfDoc.embedFont(PDFLib.StandardFonts.TimesRomanBold);

        // Register fontkit if available
        if (typeof fontkit !== 'undefined') {
            try {
                pdfDoc.registerFontkit(fontkit);
                console.log('âœ… Fontkit registered successfully');
            } catch (err) {
                console.log('âš ï¸ Fontkit registration failed:', err.message);
            }
        }

        // Load custom Maiandra font
        let maiandraFont = timesBold; // Final fallback
        
        try {
            const fontUrls = [
                'https://cdn.jsdelivr.net/gh/cwagtracker/Tracker@main/fonts/Maiandra%20GD.TTF',
                'https://raw.githubusercontent.com/cwagtracker/Tracker/main/fonts/Maiandra%20GD.TTF'
            ];
            
            let fontLoaded = false;
            for (const fontUrl of fontUrls) {
                if (fontLoaded) break;
                
                try {
                    console.log('ðŸŽ¨ Trying font URL:', fontUrl);
                    const fontResponse = await fetch(fontUrl, {
                        mode: 'cors',
                        headers: { 'Accept': 'application/octet-stream, */*' }
                    });
                    
                    if (fontResponse.ok) {
                        const fontBytes = await fontResponse.arrayBuffer();
                        console.log('ðŸ“ Font bytes loaded, size:', fontBytes.byteLength);
                        
                        if (typeof fontkit !== 'undefined') {
                            try {
                                maiandraFont = await pdfDoc.embedFont(fontBytes);
                                console.log('âœ… Maiandra GD font successfully embedded!');
                                fontLoaded = true;
                                break;
                            } catch (embedError) {
                                console.log('âŒ Custom font embed failed:', embedError.message);
                            }
                        }
                    }
                } catch (fetchError) {
                    console.log('âš ï¸ Font fetch failed for', fontUrl, ':', fetchError.message);
                }
            }
            
            if (!fontLoaded) {
                console.log('ðŸ“ Using Times-Roman-Bold (elegant serif fallback)');
                maiandraFont = timesBold;
            }
            
        } catch (error) {
            console.log('ðŸ”„ Font loading error, using Times-Roman-Bold:', error.message);
            maiandraFont = timesBold;
        }

        // Add registration number
        const regConfig = titleCertificateConfig.registrationNumber;
        firstPage.drawText(regNumber, {
            x: regConfig.x,
            y: regConfig.y,
            size: regConfig.size,
            font: font,
            color: PDFLib.rgb(regConfig.color[0], regConfig.color[1], regConfig.color[2])
        });

        // Add handler name
        let handlerName = 'Handler Name';
        if (globalData && globalData.length > 1) {
            const dogData = globalData.slice(1).find(row => 
                row && row[0] && row[0].toString().trim() === regNumber.toString().trim()
            );
            if (dogData && dogData[7]) {
                handlerName = dogData[7].toString().trim();
            }
        }
        
        const handlerConfig = titleCertificateConfig.handlerName;
        const handlerTextWidth = maiandraFont.widthOfTextAtSize(handlerName, handlerConfig.size);
        const handlerX = handlerConfig.align === 'center' ? handlerConfig.x - (handlerTextWidth / 2) : handlerConfig.x;
        
        firstPage.drawText(handlerName, {
            x: handlerX,
            y: handlerConfig.y,
            size: handlerConfig.size,
            font: maiandraFont,
            color: PDFLib.rgb(0, 0, 0)
        });

        // Add dog name
        const dogConfig = titleCertificateConfig.dogName;
        const dogTextWidth = maiandraFont.widthOfTextAtSize(dogName, dogConfig.size);
        const dogX = dogConfig.align === 'center' ? dogConfig.x - (dogTextWidth / 2) : dogConfig.x;
        
        firstPage.drawText(dogName, {
            x: dogX,
            y: dogConfig.y,
            size: dogConfig.size,
            font: maiandraFont,
            color: PDFLib.rgb(0, 0, 0)
        });

        // Add date in sentence format
        const dateConfig = titleCertificateConfig.dateEarned;
        
        firstPage.drawText('On ', {
            x: dateConfig.x - 20,
            y: dateConfig.y,
            size: dateConfig.size,
            font: font,
            color: PDFLib.rgb(dateConfig.color[0], dateConfig.color[1], dateConfig.color[2])
        });
        
        firstPage.drawText(dateEarned, {
            x: dateConfig.x,
            y: dateConfig.y,
            size: dateConfig.size,
            font: font,
            color: PDFLib.rgb(dateConfig.color[0], dateConfig.color[1], dateConfig.color[2])
        });
        
        const dateWidth = font.widthOfTextAtSize(dateEarned, dateConfig.size);
        firstPage.drawText(', has completed the requirements for the title of', {
            x: dateConfig.x + dateWidth,
            y: dateConfig.y,
            size: dateConfig.size,
            font: font,
            color: PDFLib.rgb(dateConfig.color[0], dateConfig.color[1], dateConfig.color[2])
        });

        // Add title using the proper certificate name from Column C + abbreviation
        const titleConfig = titleCertificateConfig.titleAbbreviation;
        
        // Format: "Detective Diversions (CW-SDD)" - using Column C name
        const titleText = `${certificateName} (${abbreviation})`;
        const titleTextWidth = timesBold.widthOfTextAtSize(titleText, titleConfig.size);
        const titleX = titleConfig.align === 'right' ? titleConfig.x - titleTextWidth : titleConfig.x;
        
        firstPage.drawText(titleText, {
            x: titleX,
            y: titleConfig.y,
            size: titleConfig.size,
            font: maiandraFont,
            color: PDFLib.rgb(titleConfig.color[0], titleConfig.color[1], titleConfig.color[2])
        });

        // Save and download
        const pdfBytes = await pdfDoc.save();
        downloadPDF(pdfBytes, `${dogName}-${level.replace(/\s+/g, '-')}-Title-Certificate.pdf`);

        btn.textContent = originalText;
        btn.disabled = false;

    } catch (error) {
        console.error('Certificate generation error:', error);
        alert(`Unable to generate certificate: ${error.message}\n\nPlease check that the certificate templates are available in your GitHub repository.`);
        
        const btn = event.target;
        btn.textContent = 'ðŸ“œ Title Certificate';
        btn.disabled = false;
    }
}

// Updated generateAceCertificate function
async function generateAceCertificate(level, regNumber, dogName, aceCount) {
    try {
        const btn = event.target;
        const originalText = btn.textContent;
        btn.textContent = 'Generating...';
        btn.disabled = true;

        // Get dog's records for this level to calculate date earned
        const levelRecords = trialingData.filter(r => 
            r.registrationNumber === regNumber && r.level === level
        );

        if (levelRecords.length === 0) {
            throw new Error('No records found for this level');
        }

        // Calculate when the ACE was earned
        const titleInfo = calculateTitlePoints(levelRecords);
        const dateEarned = titleInfo.titleDate ? titleInfo.titleDate.toLocaleDateString() : new Date().toLocaleDateString();

        // Get the proper ACE certificate name from Title Placement data (Column D)
        const aceCertificateName = getAceCertificateName(level, aceCount);

        // ACE certificates use dedicated Ace.pdf template
        const templateUrl = 'https://raw.githubusercontent.com/cwagtracker/Tracker/main/templates/Ace.pdf';
        
        let templateBytes;
        try {
            const response = await fetch(templateUrl);
            if (!response.ok) {
                throw new Error(`ACE template not found: ${templateUrl}`);
            }
            templateBytes = await response.arrayBuffer();
        } catch (fetchError) {
            console.warn('ACE template not available, creating basic ace certificate:', fetchError);
            return await createFallbackAceCertificate(dogName, regNumber, level, aceCertificateName, aceCount);
        }

        // Load the ACE template PDF
        const pdfDoc = await PDFLib.PDFDocument.load(templateBytes);
        const pages = pdfDoc.getPages();
        const firstPage = pages[0];
        
        // Register fontkit for custom fonts
        if (typeof fontkit !== 'undefined') {
            try {
                pdfDoc.registerFontkit(fontkit);
                console.log('âœ… Fontkit registered for ACE certificate');
            } catch (err) {
                console.log('âš ï¸ Fontkit registration failed:', err.message);
            }
        }

        // Embed fonts
        const helvetica = await pdfDoc.embedFont(PDFLib.StandardFonts.Helvetica);
        const calibriFont = helvetica; // Fallback to Helvetica if Calibri not available
        
        // Load Maiandra GD font
        let maiandraFont = await pdfDoc.embedFont(PDFLib.StandardFonts.TimesRomanBold); // Fallback
        
        try {
            const fontUrls = [
                'https://cdn.jsdelivr.net/gh/cwagtracker/Tracker@main/fonts/Maiandra%20GD.TTF',
                'https://raw.githubusercontent.com/cwagtracker/Tracker/main/fonts/Maiandra%20GD.TTF'
            ];
            
            for (const fontUrl of fontUrls) {
                try {
                    console.log('ðŸŽ¨ Loading Maiandra font for ACE certificate:', fontUrl);
                    const fontResponse = await fetch(fontUrl, {
                        mode: 'cors',
                        headers: { 'Accept': 'application/octet-stream, */*' }
                    });
                    
                    if (fontResponse.ok) {
                        const fontBytes = await fontResponse.arrayBuffer();
                        if (typeof fontkit !== 'undefined') {
                            maiandraFont = await pdfDoc.embedFont(fontBytes);
                            console.log('âœ… Maiandra GD font loaded for ACE certificate!');
                            break;
                        }
                    }
                } catch (err) {
                    console.log('âš ï¸ Maiandra font load failed:', err.message);
                }
            }
        } catch (error) {
            console.log('ðŸ”„ Using Times-Roman-Bold fallback for Maiandra');
        }

        // Get handler name from global data
        let handlerName = 'Handler Name';
        if (globalData && globalData.length > 1) {
            const dogData = globalData.slice(1).find(row => 
                row && row[0] && row[0].toString().trim() === regNumber.toString().trim()
            );
            if (dogData && dogData[7]) {
                handlerName = dogData[7].toString().trim();
            }
        }

        // Helper function to draw text with alignment
        function drawTextWithAlignment(page, text, config, font) {
            let x = config.x;
            
            if (config.align === 'center') {
                const textWidth = font.widthOfTextAtSize(text, config.size);
                x = config.x - (textWidth / 2);
            } else if (config.align === 'right') {
                const textWidth = font.widthOfTextAtSize(text, config.size);
                x = config.x - textWidth;
            }
            
            page.drawText(text, {
                x: x,
                y: config.y,
                size: config.size,
                font: font,
                color: PDFLib.rgb(config.color[0], config.color[1], config.color[2])
            });
        }

        // 1. Date line
        const dateLineText = `This certifies that on ${dateEarned} the requirements have been met for the title of:`;
        drawTextWithAlignment(firstPage, dateLineText, aceCertificateConfig.dateLine, calibriFont);

        // 2. ACE Certificate name from Column D (e.g., "SCENT DETECTIVE DIVERSIONS ACE x3")
        drawTextWithAlignment(firstPage, aceCertificateName, aceCertificateConfig.levelAbbreviation, maiandraFont);

        // 3. Call name (dog name)
        drawTextWithAlignment(firstPage, dogName, aceCertificateConfig.callName, maiandraFont);

        // 4. Handler name
        drawTextWithAlignment(firstPage, handlerName, aceCertificateConfig.handlerName, maiandraFont);

        // 5. Registration number
        drawTextWithAlignment(firstPage, regNumber, aceCertificateConfig.registrationNumber, calibriFont);

        // Save and download the ACE certificate
        const pdfBytes = await pdfDoc.save();
        downloadPDF(pdfBytes, `${dogName}-${level.replace(/\s+/g, '-')}-ACE-Certificate.pdf`);

        btn.textContent = originalText;
        btn.disabled = false;

    } catch (error) {
        console.error('ACE certificate generation error:', error);
        alert(`Unable to generate ACE certificate: ${error.message}\n\nPlease check that the Ace.pdf template is available in your GitHub repository.`);
        
        const btn = event.target;
        btn.textContent = 'ðŸ† Ace Certificate';
        btn.disabled = false;
    }
}

// Update the document ready function to load Title Placement data
document.addEventListener('DOMContentLoaded', function() {
    document.getElementById('lastUpdated').textContent = 'Loading data...';
    
    // Check if fontkit loaded
    setTimeout(() => {
        if (typeof fontkit !== 'undefined') {
            console.log('âœ… Fontkit library loaded successfully');
        } else {
            console.warn('âš ï¸ Fontkit library failed to load - custom fonts will not work');
        }
    }, 1000);
    
    setTimeout(async () => {
        // Load Title Placement data first
        await loadTitlePlacementData();
        
        // Then load trialing data
        loadDataFromFile();
    }, 100);
});